esphome:
  name: office-airplane-tracker
  friendly_name: Office Airplane Tracker
  on_boot:
    priority: -10
    then:
      - display.page.show: screen1_overview

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:
  level: DEBUG

api:
  encryption:
    key: "v1P6+bNnUhX54j4FVGmKsC+AMc448uYdUCD+EIQdAcM="

ota:
  - platform: esphome
    password: "ca2e0204b861d99c73c3d91e05ef47f7"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Office-Airplane-Tracker"
    password: "cscuPSHIzHho"

captive_portal:

# ---------------- TIME (for ETA computation) ----------------
time:
  - platform: homeassistant
    id: ha_time

# ---------------- MQTT (subscribe to nearest JSON) ----------------
# Parses the raw nearest JSON on ${NEAREST_TOPIC} and updates display globals.
mqtt:
  broker: ${MQTT_HOST}
  port: ${MQTT_PORT}
  username: ${MQTT_USERNAME}
  password: ${MQTT_PASSWORD}
  on_json_message:
    - topic: ${NEAREST_TOPIC}
      then:
        - lambda: |-
            // x is the JsonObject for the nearest payload
            // route.origin / route.destination (IATA if available)
            if (x.containsKey("origin_iata")) {
              const char* s = x["origin_iata"].as<const char*>();
              if (s) id(route_origin) = std::string(s);
            }
            if (x.containsKey("destination_iata")) {
              const char* s = x["destination_iata"].as<const char*>();
              if (s) id(route_destination) = std::string(s);
            }

            // Airline / aircraft lookups
            if (x.containsKey("lookups")) {
              auto lk = x["lookups"].as<JsonObject>();
              if (!lk.isNull()) {
                auto al = lk["airline"].as<JsonObject>();
                if (!al.isNull()) {
                  const char* n = al["name"].as<const char*>();
                  if (n) id(airline_name) = std::string(n);
                }
                auto ac = lk["aircraft"].as<JsonObject>();
                if (!ac.isNull()) {
                  const char* n = ac["name"].as<const char*>();
                  if (n) id(aircraft_name) = std::string(n);
                }
              }
            }

            // Callsign
            if (x.containsKey("callsign")) {
              const char* s = x["callsign"].as<const char*>();
              id(callsign) = s ? std::string(s) : std::string("");
            }

            // Distances/speeds/altitude
            if (x.containsKey("distance_nm")) {
              float d = x["distance_nm"].as<float>();
              id(distance_now_km) = d * 1.852f;
            }
            if (x.containsKey("ground_speed_kt")) {
              float v = x["ground_speed_kt"].as<float>();
              id(ground_speed_kmh) = (int) roundf(v * 1.852f);
            }
            if (x.containsKey("altitude_ft")) id(altitude_ft) = x["altitude_ft"].as<int>();
            if (x.containsKey("vertical_rate_fpm")) id(vertical_rate_fpm) = x["vertical_rate_fpm"].as<int>();

          // Remaining distance + ETA
          if (x.containsKey("remaining_nm")) {
            float rem = x["remaining_nm"].as<float>();
            id(distance_remaining_km) = rem * 1.852f;
          }
            if (x.containsKey("eta_min")) {
              float mins = x["eta_min"].as<float>();
              auto now = id(ha_time).now();
              if (now.is_valid()) {
                uint32_t ts = now.timestamp + (uint32_t) (mins * 60.0f);
                auto eta = ESPTime::from_epoch_local(ts);
                char buf[6];
                snprintf(buf, sizeof(buf), "%02d:%02d", eta.hour, eta.minute);
                id(eta_local_hhmm) = std::string(buf);
              } else {
                id(eta_local_hhmm) = std::string("--:--");
              }
            }

            // Direction: 8-point compass from bearing_deg
            if (x.containsKey("bearing_deg")) {
              int b = x["bearing_deg"].as<int>();
              static const char* dirs[8] = {"N","NE","E","SE","S","SW","W","NW"};
              int idx = ((b % 360) + 360) % 360; // normalize
              idx = (int) floorf((idx + 22.5f) / 45.0f) % 8;
              id(direction_cardinal) = std::string(dirs[idx]);
            }

            // Souls on board: prefer explicit if provided; else use max seats as proxy
            if (x.containsKey("souls_on_board")) {
              id(souls_on_board) = x["souls_on_board"].as<int>();
            } else if (x.containsKey("souls_on_board_max")) {
              id(souls_on_board) = x["souls_on_board_max"].as<int>();
            }

          // Radar model
          if (x.containsKey("bearing_deg")) id(radar_bearing_deg) = x["bearing_deg"].as<int>();
          if (x.containsKey("distance_nm")) id(radar_range_km) = x["distance_nm"].as<float>() * 1.852f;
          if (x.containsKey("vertical_rate_fpm")) id(radar_rel_vertical_fpm) = x["vertical_rate_fpm"].as<int>();
          if (x.containsKey("ground_speed_kt")) id(radar_gs_kmh) = (int) roundf(x["ground_speed_kt"].as<float>() * 1.852f);
          if (x.containsKey("track_deg")) id(radar_heading_deg) = x["track_deg"].as<int>();
          if (x.containsKey("latitude")) id(radar_center_lat) = x["latitude"].as<float>();
          if (x.containsKey("longitude")) id(radar_center_lon) = x["longitude"].as<float>();

            // Optional: history[] rows → compact strings for Screen 2
            if (x.containsKey("history")) {
              auto arr = x["history"].as<JsonArray>();
              if (!arr.isNull()) {
                auto fmt_row = [](JsonObject obj) -> std::string {
                  std::string flight = obj["flight"].is<const char*>() ? obj["flight"].as<const char*>() : "";
                  std::string origin = obj["origin"].is<const char*>() ? obj["origin"].as<const char*>() : "";
                  std::string dest = obj["destination"].is<const char*>() ? obj["destination"].as<const char*>() : "Unknown";
                  std::string date = obj["date_yyyy_mm_dd"].is<const char*>() ? obj["date_yyyy_mm_dd"].as<const char*>() : "";
                  std::string block = obj["block_time_hhmm"].is<const char*>() ? obj["block_time_hhmm"].as<const char*>() : "";
                  std::string eta = obj["arr_or_eta_hhmm"].is<const char*>() ? obj["arr_or_eta_hhmm"].as<const char*>() : "";
                  char buf[128];
                  snprintf(buf, sizeof(buf), "%s  %s→%s  %s  %s  %s",
                          flight.c_str(), origin.c_str(), dest.c_str(), date.c_str(), block.c_str(), eta.c_str());
                  return std::string(buf);
                };
                int idx = 0;
                for (JsonObject row : arr) {
                  std::string line = fmt_row(row);
                  if (idx == 0) id(hist1) = line;
                  else if (idx == 1) id(hist2) = line;
                  else if (idx == 2) id(hist3) = line;
                  else if (idx == 3) id(hist4) = line;
                  else if (idx == 4) id(hist5) = line;
                  idx++;
                  if (idx >= 5) break;
                }
              }
            }

            // Refresh display after updating fields
            id(tft).update();
# ---------------- NAV/BUTTON PIN SUBSTITUTIONS ----------------
# Provide real GPIOs for your hardware. For ESP32-C3 DevKitM-1,
# avoid boot-strapping pins. Example safe choices are GPIO2/GPIO3/GPIO20.
substitutions:
  BTN_A_PIN: GPIO2      # Opens Gallery (Screen 2)
  BTN_B_PIN: GPIO3      # Opens Radar (Screen 3)
  BTN_BACK_PIN: GPIO20  # Back to previous screen
  # MQTT broker info (fill with your broker / HA MQTT add-on)
  MQTT_HOST: 192.168.1.10
  MQTT_PORT: "1883"
  MQTT_USERNAME: ""
  MQTT_PASSWORD: ""
  MQTT_PREFIX: airtracker
  NEAREST_TOPIC: ${MQTT_PREFIX}/nearest

# ---------------- SPI (YOUR WORKING PINS) ----------------
spi:
  id: spi_bus
  clk_pin: GPIO4
  mosi_pin: GPIO6          # must show up as "SDI Pin: GPIO6" in logs
  miso_pin: GPIO5          # ok to keep since it's working for you

# ---------------- FONTS ----------------
# Declare display fonts. Use a monospaced font for numeric fields.
font:
  # Header (~28 px)
  - file: "gfonts://Roboto"
    id: f_header
    size: 28
  # Body (18–22 px)
  - file: "gfonts://Roboto"
    id: f_body
    size: 20
  # Labels (12–14 px)
  - file: "gfonts://Roboto"
    id: f_label
    size: 13
  # Mono for numbers (18–22 px)
  - file: "gfonts://Roboto Mono"
    id: f_mono
    size: 20
  # Mono larger for center count (24–28 px)
  - file: "gfonts://Roboto Mono"
    id: f_mono_big
    size: 26
# If gfonts fails in your environment, place local TTFs and point to paths, e.g.:
#  - file: "/config/esphome/fonts/Roboto-Regular.ttf"
#  - file: "/config/esphome/fonts/RobotoMono-Regular.ttf"

# ---------------- IMAGE PLACEHOLDERS ----------------
# Plane and airline logo are placeholders compiled into firmware.
# When integrating with HA/MQTT + planelookerupper.py, you will update these
# files before compiling (dynamic image loading at runtime is not supported).
image:
  - file: "display/assets/logo.png"
    id: img_logo
    type: RGB565
    resize: 64x64
  - file: "display/assets/plane.png"
    id: img_plane
    type: RGB565
    resize: 80x64

# ---------------- DATA MODEL (Mock values; bind to HA later) ----------------
globals:
  # Route / progress
  - id: route_origin
    type: std::string
    initial_value: '"SEA"'
  - id: route_destination
    type: std::string
    initial_value: '"SFO"'
  - id: distance_remaining_km
    type: float
    initial_value: '412'
  - id: eta_local_hhmm
    type: std::string
    initial_value: '"18:23"'

  # Airline / aircraft
  - id: airline_name
    type: std::string
    initial_value: '"Alaska Airlines"'
  - id: aircraft_name
    type: std::string
    initial_value: '"Boeing 737-800"'
  - id: callsign
    type: std::string
    initial_value: '"ASA345"'   # can be empty

  # Overview metrics
  - id: souls_on_board
    type: int
    initial_value: '178'
  - id: distance_now_km
    type: float
    initial_value: '34.2'
  - id: direction_cardinal
    type: std::string
    initial_value: '"SW"'
  - id: ground_speed_kmh
    type: int
    initial_value: '713'
  - id: altitude_ft
    type: int
    initial_value: '10975'
  - id: vertical_rate_fpm
    type: int
    initial_value: '1240'

  # Gallery header
  - id: registration
    type: std::string
    initial_value: '"N123AS"'
  - id: short_type
    type: std::string
    initial_value: '"B738"'

  # History rows (preformatted for compactness)
  - id: hist1
    type: std::string
    initial_value: '"ASA345  SEA→SFO  2025-09-13  02:07  Arr 18:12"'
  - id: hist2
    type: std::string
    initial_value: '"ASA862  PDX→SEA  2025-09-12  00:40  Arr 15:21"'
  - id: hist3
    type: std::string
    initial_value: '"ASA217  SFO→SEA  2025-09-10  02:03  Arr 19:03"'
  - id: hist4
    type: std::string
    initial_value: '"ASA1189 LAX→SFO  2025-09-08  01:18  Arr 11:47"'
  - id: hist5
    type: std::string
    initial_value: '"ASA345  SEA→SFO  2025-09-05  02:05  Arr 17:59"'

  # Radar model
  - id: radar_bearing_deg
    type: int
    initial_value: '224'
  - id: radar_range_km
    type: float
    initial_value: '4.7'
  - id: radar_rel_vertical_fpm
    type: int
    initial_value: '1200'
  - id: radar_gs_kmh
    type: int
    initial_value: '712'
  - id: radar_heading_deg
    type: int
    initial_value: '220'
  - id: radar_center_lat
    type: float
    initial_value: '47.61'
  - id: radar_center_lon
    type: float
    initial_value: '-122.33'
  - id: radar_range_scale_km
    type: int
    initial_value: '10'   # cycle 2/5/10/20 later

  # Simple page stack for BACK behavior (0=overview,1=gallery,2=radar)
  - id: current_screen
    type: int
    restore_value: no
    initial_value: '0'
  - id: previous_screen
    type: int
    restore_value: no
    initial_value: '0'

  # Optional overlay debug
  - id: show_overlay
    type: bool
    restore_value: yes
    initial_value: 'false'

# Display updates are demand-driven by navigation and data updates
interval:
  - interval: 250ms
    then:
      - component.update: tft


# ---------------- PHYSICAL BUTTONS (Navigation) ----------------
binary_sensor:
  - platform: gpio
    id: btn_a
    pin:
      number: ${BTN_A_PIN}
      mode: INPUT_PULLUP
      inverted: true
    name: "BTN_A (Next Screen)"
    on_press:
      - lambda: |-
          id(previous_screen) = id(current_screen);
          id(current_screen) = (id(current_screen) + 1) % 3;
          if (id(current_screen) == 0) {
            id(tft).show_page(id(screen1_overview));
          } else if (id(current_screen) == 1) {
            id(tft).show_page(id(screen2_gallery));
          } else {
            id(tft).show_page(id(screen3_radar));
          }
  - platform: gpio
    id: btn_b
    pin:
      number: ${BTN_B_PIN}
      mode: INPUT_PULLUP
      inverted: true
    name: "BTN_B (Next Screen)"
    on_press:
      - lambda: |-
          id(previous_screen) = id(current_screen);
          id(current_screen) = (id(current_screen) + 1) % 3;
          if (id(current_screen) == 0) {
            id(tft).show_page(id(screen1_overview));
          } else if (id(current_screen) == 1) {
            id(tft).show_page(id(screen2_gallery));
          } else {
            id(tft).show_page(id(screen3_radar));
          }
  - platform: gpio
    id: btn_back
    pin:
      number: ${BTN_BACK_PIN}
      mode: INPUT_PULLUP
      inverted: true
    name: "BTN_BACK (Next Screen)"
    on_press:
      - lambda: |-
          id(previous_screen) = id(current_screen);
          id(current_screen) = (id(current_screen) + 1) % 3;
          if (id(current_screen) == 0) {
            id(tft).show_page(id(screen1_overview));
          } else if (id(current_screen) == 1) {
            id(tft).show_page(id(screen2_gallery));
          } else {
            id(tft).show_page(id(screen3_radar));
          }

# ---------------- HA EXPOSED VIRTUAL BUTTONS (no hardware needed) ----------------
button:
  - platform: template
    name: "Screen: Next"
    on_press:
      - lambda: |-
          id(previous_screen) = id(current_screen);
          id(current_screen) = (id(current_screen) + 1) % 3;
          if (id(current_screen) == 0) {
            id(tft).show_page(id(screen1_overview));
          } else if (id(current_screen) == 1) {
            id(tft).show_page(id(screen2_gallery));
          } else {
            id(tft).show_page(id(screen3_radar));
          }
  - platform: template
    name: "Screen: Previous"
    on_press:
      - lambda: |-
          id(previous_screen) = id(current_screen);
          // (current - 1) mod 3
          id(current_screen) = (id(current_screen) + 2) % 3;
          if (id(current_screen) == 0) {
            id(tft).show_page(id(screen1_overview));
          } else if (id(current_screen) == 1) {
            id(tft).show_page(id(screen2_gallery));
          } else {
            id(tft).show_page(id(screen3_radar));
          }

switch:
  - platform: template
    name: "TFT Overlay (FPS/labels)"
    optimistic: true
    turn_on_action:  { lambda: 'id(show_overlay) = true;' }
    turn_off_action: { lambda: 'id(show_overlay) = false;' }

# ---------------- DISPLAY (Three screens @ 320x240) ----------------
display:
  - platform: ili9xxx
    id: tft
    model: ILI9341
    invert_colors: false
    spi_id: spi_bus
    cs_pin: GPIO7
    dc_pin: GPIO10
    reset_pin: GPIO1
    data_rate: 40MHz
    spi_mode: MODE0
    color_palette: 8BIT        # 3:3:2 palette (fast, OK for UI)
    color_order: RGB
    update_interval: 0s
    pages:
      # ---------------- SCREEN 1 — FLIGHT OVERVIEW ----------------
      - id: screen1_overview
        lambda: |-
          // Canvas: 320x240, landscape. Black background.
          it.fill(Color::BLACK);

          // Helpers: colors and geometry
          const int W = it.get_width();
          const int H = it.get_height();
          const int M = 8; // safe margin

          auto WHITE = Color::WHITE;
          auto DIM = Color(180, 180, 180);

          // Utility: simple ellipsis for strings beyond max chars
          auto ellipsize = [](std::string s, size_t max_chars) -> std::string {
            if (s.size() <= max_chars) return s;
            if (max_chars <= 1) return "…";
            return s.substr(0, max_chars-1) + "…";
          };

          // 1) TOP BAR (8,8,304,36)
          const int top_x = 8, top_y = 8, top_w = 304, top_h = 36;
          // Left: "{origin} → {destination or 'Unknown'}"
          std::string dest = id(route_destination).empty() ? std::string("Unknown") : id(route_destination);
          std::string route = id(route_origin) + " → " + dest;
          it.printf(top_x, top_y + 4, id(f_header), WHITE, "%s", route.c_str());
          // Right: "{distance_remaining_km} km • ETA {eta_local_hhmm}"
          it.printf(top_x + top_w, top_y + 8, id(f_label), WHITE, TextAlign::TOP_RIGHT,
                    "%.0f km • ETA %s", id(distance_remaining_km), id(eta_local_hhmm).c_str());

          // 2) CENTER BAND (8,52,304,92)
          const int band_x = 8, band_y = 52, band_w = 304, band_h = 92;
          // LOGO box (8,56,64,64)
          const int logo_x = 8, logo_y = 56, logo_w = 64, logo_h = 64;
          it.rectangle(logo_x, logo_y, logo_w, logo_h, DIM);
          {
            // Center logo with letterboxing
            int lw = id(img_logo).get_width();
            int lh = id(img_logo).get_height();
            int ox = logo_x + (logo_w - lw)/2;
            int oy = logo_y + (logo_h - lh)/2;
            it.image(ox, oy, id(img_logo));
          }

          // Text block (80,56,144,64)
          const int text_x = 80, text_y = 56, text_w = 144, text_h = 64;
          std::string line1 = id(aircraft_name) + " — " + id(airline_name);
          it.printf(text_x, text_y, id(f_body), WHITE, "%s", ellipsize(line1, 28).c_str());
          if (!id(callsign).empty())
            it.printf(text_x, text_y + 26, id(f_body), DIM, "Callsign: %s", id(callsign).c_str());

          // Plane image (232,56,80,64)
          const int plane_x = 232, plane_y = 56, plane_w = 80, plane_h = 64;
          it.rectangle(plane_x, plane_y, plane_w, plane_h, DIM);
          {
            int pw = id(img_plane).get_width();
            int ph = id(img_plane).get_height();
            int ox = plane_x + (plane_w - pw)/2;
            int oy = plane_y + (plane_h - ph)/2;
            it.image(ox, oy, id(img_plane));
          }

          // Optional soft button label for RADAR
          it.printf(W - M - 4, band_y + band_h + 4, id(f_label), DIM, TextAlign::TOP_RIGHT, "RADAR ▶");

          // 3) BOTTOM BAR (8,196,304,36)
          const int bot_x = 8, bot_y = 196, bot_w = 304, bot_h = 36;
          // LEFT (8,196,124,36)
          it.printf(bot_x, bot_y + 8, id(f_body), WHITE, "%.1f km – %s • %d km/h",
                    id(distance_now_km), id(direction_cardinal).c_str(), id(ground_speed_kmh));
          // CENTER (132,196,56,36) souls on board
          // Draw a subtle box to emphasize
          it.rectangle(132, bot_y, 56, bot_h, DIM);
          it.printf(132 + 28, bot_y + 4, id(f_mono_big), WHITE, TextAlign::TOP_CENTER, "%d", id(souls_on_board));
          // RIGHT (188,196,124,36) altitude / vvi
          const char* vdir = id(vertical_rate_fpm) > 0 ? "▲" : (id(vertical_rate_fpm) < 0 ? "▼" : " ");
          int vmag = id(vertical_rate_fpm) >= 0 ? id(vertical_rate_fpm) : -id(vertical_rate_fpm);
          char vsign = id(vertical_rate_fpm) > 0 ? '+' : (id(vertical_rate_fpm) < 0 ? '-' : ' ');
          it.printf(bot_x + bot_w, bot_y + 8, id(f_body), WHITE, TextAlign::TOP_RIGHT,
                    "%d ft %s %c%d fpm", id(altitude_ft), vdir, vsign, vmag);

          if (id(show_overlay)) {
            it.rectangle(M, M, W - 2*M, H - 2*M, DIM);
          }

      # ---------------- SCREEN 2 — GALLERY + LAST 5 FLIGHTS ----------------
      - id: screen2_gallery
        lambda: |-
          it.fill(Color::BLACK);
          const int W = it.get_width();
          const int H = it.get_height();
          const int M = 8;
          auto WHITE = Color::WHITE;
          auto DIM = Color(180, 180, 180);

          // Header (8,8,304,24)
          it.printf(8, 8, id(f_label), WHITE, "← Back");
          std::string hdr = (id(registration).empty() ? (id(callsign).empty() ? std::string("(hex)") : id(callsign)) : id(registration))
                            + " (" + id(short_type) + ") — " + id(airline_name);
          it.printf(64, 8, id(f_body), WHITE, "%s", hdr.c_str());

          // Thumbnails grid (2x2) top half
          struct Box { int x; int y; int w; int h; };
          Box boxes[4] = {{8,44,120,68},{168,44,120,68},{8,120,120,68},{168,120,120,68}};
          for (int i=0;i<4;i++) {
            auto &b = boxes[i];
            it.rectangle(b.x, b.y, b.w, b.h, DIM);
            int pw = id(img_plane).get_width();
            int ph = id(img_plane).get_height();
            int ox = b.x + (b.w - pw)/2;
            int oy = b.y + (b.h - ph)/2;
            it.image(ox, oy, id(img_plane));
          }

          // List: Last 5 flights (start y≈196)
          it.printf(8, 196, id(f_label), DIM, "Last 5 flights");
          const int row_h = 10; // compact rows
          it.printf(8, 208, id(f_label), WHITE, "%s", id(hist1).c_str());
          it.printf(8, 208 + row_h, id(f_label), WHITE, "%s", id(hist2).c_str());
          it.printf(8, 208 + 2*row_h, id(f_label), WHITE, "%s", id(hist3).c_str());
          it.printf(8, 208 + 3*row_h, id(f_label), WHITE, "%s", id(hist4).c_str());
          it.printf(8, 208 + 4*row_h, id(f_label), WHITE, "%s", id(hist5).c_str());

      # ---------------- SCREEN 3 — MINI RADAR ----------------
      - id: screen3_radar
        lambda: |-
          it.fill(Color::BLACK);
          const int W = it.get_width();
          const int H = it.get_height();
          const int M = 8;
          auto WHITE = Color::WHITE;
          auto DIM = Color(160, 160, 160);

          // Top bar (8,8,304,24)
          it.printf(8, 8, id(f_label), WHITE, "← Back");
          it.printf(W/2, 8, id(f_label), WHITE, TextAlign::TOP_CENTER,
                    "RADAR (%d km)", id(radar_range_scale_km));
          it.printf(W - 8, 8, id(f_label), DIM, TextAlign::TOP_RIGHT, "RECENTER");

          // Scope: center (160,124), radius ≈96
          const int cx = 160, cy = 124, R = 96;
          it.circle(cx, cy, R, WHITE);
          // Range rings
          it.circle(cx, cy, (int)(R*0.33f), DIM);
          it.circle(cx, cy, (int)(R*0.66f), DIM);
          // Crosshair
          it.line(cx - R, cy, cx + R, cy, DIM);
          it.line(cx, cy - R, cx, cy + R, DIM);
          // Cardinal ticks N/E/S/W
          it.printf(cx, cy - R - 10, id(f_label), WHITE, TextAlign::TOP_CENTER, "N");
          it.printf(cx + R + 4, cy - 6, id(f_label), WHITE, "E");
          it.printf(cx, cy + R + 2, id(f_label), WHITE, TextAlign::TOP_CENTER, "S");
          it.printf(cx - R - 8, cy - 6, id(f_label), WHITE, "W");

          // Target plotting
          float rng = id(radar_range_km);
          float scale = (float) id(radar_range_scale_km);
          float r = (rng / (scale > 0 ? scale : 1)) * R;
          float ang = (float) id(radar_bearing_deg) * 3.1415926f / 180.0f; // degrees -> radians
          int tx = cx + (int)(sinf(ang) * r);   // screen x uses sin for polar bearing
          int ty = cy - (int)(cosf(ang) * r);   // y inverted
          // target dot
          it.filled_circle(tx, ty, 2, Color(0, 255, 0));
          // leader line to label (bottom-left bias)
          int lx = tx - 70;
          int ly = ty + 10;
          it.line(tx, ty, lx + 70, ly - 10, DIM);
          // label box
          it.filled_rectangle(lx - 2, ly - 2, 146, 42, Color(10, 10, 10));
          it.rectangle(lx - 2, ly - 2, 146, 42, DIM);
          // label text (12–14 px)
          const char* rel_dir = (id(radar_rel_vertical_fpm) > 0) ? "▲" : ((id(radar_rel_vertical_fpm) < 0) ? "▼" : " ");
          int rel_mag = id(radar_rel_vertical_fpm) >= 0 ? id(radar_rel_vertical_fpm) : -id(radar_rel_vertical_fpm);
          it.printf(lx, ly, id(f_label), WHITE, "BRG %d°   R %.1f km", id(radar_bearing_deg), id(radar_range_km));
          it.printf(lx, ly + 12, id(f_label), WHITE, "REL ALT %s%d fpm", rel_dir, rel_mag);
          it.printf(lx, ly + 24, id(f_label), WHITE, "GS %d km/h   HDG %d°", id(radar_gs_kmh), id(radar_heading_deg));

          // Footer strip (8,216,304,16)
          it.printf(8, 216, id(f_label), DIM, "RNG: %d km", id(radar_range_scale_km));
          it.printf(W/2, 216, id(f_label), DIM, TextAlign::TOP_CENTER, "BEARING: %s", id(direction_cardinal).c_str());
          it.printf(W - 8, 216, id(f_label), DIM, TextAlign::TOP_RIGHT,
                    "COORD: %.2f°, %.2f°", id(radar_center_lat), id(radar_center_lon));

# ---------------- TOUCHSCREEN (optional) ----------------
# If your TFT has a touch controller (e.g., XPT2046/FT6x36), configure it here
# and map tap zones to navigation. Left commented to honor "no networking" and
# keep this self-contained.
# touchscreen:
#   - platform: xpt2046
#     cs_pin: GPIO9
#     irq_pin: GPIO0
#     update_interval: 30ms
#     on_touch:
#       - lambda: |-
#           // Plane image box (232,56,80,64) → Screen 2
#           if (x >= 232 && x < 312 && y >= 56 && y < 120) {
#             id(previous_screen) = id(current_screen);
#             id(current_screen) = 1; id(tft).show_page(id(screen2_gallery));
#           }
#           // Soft RADAR button (approx bottom-right of band)
#           if (x >= 240 && x < 312 && y >= 144 && y < 180) {
#             id(previous_screen) = id(current_screen);
#             id(current_screen) = 2; id(tft).show_page(id(screen3_radar));
#           }
